{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.7777777777777777,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":450,"widthMode":"fixed","height":253.125,"heightMode":"auto","left":0.5,"leftMode":"relative","top":0.5,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":1,"exposure":-0.01,"saturation":1,"contrast":1.04,"src":"https://assets.unicorn.studio/images/ldoKRzHepkRj9icRCErLhMwqpIi1/hero01.jpg","naturalWidth":1920,"naturalHeight":1080,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform int uSampleBg;const float STEPS = 24.0; const float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) { color = mix(background, color + background * (1.0 - color.a), 1.0000); return color; }vec4 getOutputByMode(vec4 color, vec4 background) { return getNormalOutput(color, background); }void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0); if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv); color.rgb = clamp(color.rgb + -0.0100, 0.0, 1.0);color.rgb = 1.0400 * (color.rgb - 0.5) + 0.5;color.rgb = clamp(color.rgb, 0.0, 1.0) * color.a;vec4 col = getOutputByMode(color, background);fragColor = col; }"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"image"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"data:image/png;base64,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","sampler":"uCustomTexture"},"trackMouse":0.01,"trackAxes":"xy","mouseMomentum":0.57,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uSprite; uniform sampler2D uCustomTexture;uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0100); float aspectRatio = uResolution.x / uResolution.y; float aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 1.0000);float baseGrid = 1.0 / gridSize; vec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection; vec2 offsetUv = uv - pos; vec2 cell = floor(offsetUv / cellSize); vec2 cellCenter = (cell + 0.5) * cellSize; vec2 pixelatedCoord = cellCenter + pos; vec4 bg = texture(uTexture, vTextureCoord); vec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722)); luminance = mix(luminance, 1.0 - luminance, float(0)); float gamma = pow(mix(0.2, 2.2, 0.6900), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0); ivec2 spriteTextureSize = textureSize(uSprite, 0); float selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(6 == 6)); float GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(6 == 6)); float scaleFactor = gridSize / GLYPH_HEIGHT; float numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT); float numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0); float spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0); float glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites; float normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2( spriteX, glyphIndex / numGlyphRows );vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection; vec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT; localOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2( localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY );vec4 spriteColor = vec4(0.0);spriteColor = texture(uCustomTexture, spriteSheetUV); float alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4; vec3 col = mix(cc, vec3(0.615686274509804, 0.615686274509804, 0.615686274509804), float(1)); vec3 dithered = mix( mix(vec3(0.0), vec3(1.0), float(0)), col, alpha ); color.rgb = mix(bg.rgb, dithered, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"fog","usesPingPong":false,"speed":0.1,"trackMouse":0.44,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.0000 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.2000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6500 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.4400); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(1.0000, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(1, 0)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.0000 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.2000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6500 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.4400); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(1.0000, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(0, 1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.0000 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.2000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6500 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.4400); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(1.0000, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(1, 1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.0000 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.2000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6500 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.4400); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(1.0000, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(1, -1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 Tonemap_ACES(vec3 x) { const float a = 2.51; const float b = 0.03; const float c = 2.43; const float d = 0.59; const float e = 0.14; return (x * (a * x + b)) / (x * (c * x + d) + e); }vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) { vec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1); vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.0000 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.2000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6500 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.4400); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 fogComposite(vec2 uv) { vec4 bg = texture(uBgTexture, uv); vec4 blur = texture(uTexture, uv); float aspectRatio = uResolution.x/uResolution.y; float fogNoise = fnoise(uv); float fogMask = clamp(fogNoise * 2., 0., 1.);vec3 grain = vec3(randFibo(uv + fogNoise));blur.rgb = chromatic_aberration(blur.rgb, uv, fogMask * 0.01 * 1.0000 * (1.0000 * 2.5)); blur.rgb = Tonemap_ACES(blur.rgb * (0.1400 + 0.5)) + grain * 0.05; vec4 foggedBlur = vec4(blur.rgb * vec3(1, 1, 1), blur.a); foggedBlur.rgb += (0.1000 * 0.25 * fogMask * vec3(1, 1, 1)); foggedBlur = mix(bg, foggedBlur, fogMask); return foggedBlur; }vec4 getColor(vec2 uv) { return fogComposite(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25},{"prop":"pass","value":3,"downSample":0.25},{"prop":"pass","value":4,"includeBg":true}]},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0.69,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv); float luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.1000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.3600, 1.0 - 0.3600); float halfRadius = 1.0940 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.5, 0.5);pos += (uMousePos - 0.5) * 0.6900; const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0216 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0216 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(bg.rgb, mix(bg.rgb, vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059), 1.0000), falloff);float alpha = max(bg.a, falloff * 1.0000); vec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"duotone","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture;out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114)); vec3 duotoneColor = mix(vec3(0.06666666666666667, 0.06666666666666667, 0.06666666666666667), vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333), gray); color = vec4(mix(color.rgb, duotoneColor, 1.0000), color.a); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"pattern","usesPingPong":false,"speed":0.25,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z))); }mat2 rotate2d(float _angle){ return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle)); } float gridSDF(vec2 st, float tile) { vec2 grid = fract(st); vec2 distToEdge = min(grid, 1.0 - grid); float minDist = min(distToEdge.x, distToEdge.y); return minDist - tile * 0.5; }float stripeSDF(vec2 st, float tile) { float x = fract(st.x - uTime * 0.05); return abs(x - 0.5) - tile * 0.5; }float arrowsSDF(vec2 st, float tile) { vec2 grid = floor(st); vec2 cell = fract(st); float checker = mod(grid.x + grid.y, 2.0); float arrow = checker > 0.5 ? cell.x : cell.y; return abs(arrow - 0.5) - tile * 0.5; }float concentricCircleSDF(vec2 st, float tile) { float r = length(st); return abs(fract(r) - 0.5) - tile * 0.5; }float circleSDF(vec2 st, float tile) { vec2 cell = fract(st) - 0.5; float dist = length(cell); return dist - tile * 0.5; }float checkerboardSDF(vec2 st, float tile) { vec2 grid = floor(st); vec2 cell = fract(st) - 0.5; float checker = mod(grid.x + grid.y, 2.0); return checker > 0.5 ? -1.0 : 1.0; }float wavyLinesSDF(vec2 st, float tile) { float wave = sin(st.x * 6.28318 + st.y * 10.0) * 0.5 + 0.5; return abs(wave - 0.5) - tile * 0.5; }float hexagonalSDF(vec2 st, float tile) { const float sqrt3 = 1.732050808; st = abs(st); float d = dot(st, normalize(vec2(1.0, sqrt3))); return max(d, st.x) - tile; }float diamondSDF(vec2 st, float tile) { vec2 cell = fract(st) - 0.5; float d = abs(cell.x) + abs(cell.y); return d - tile * 0.5; }float spiralSDF(vec2 st, float tile) { float r = length(st); float theta = atan(st.y, st.x); float spiral = fract((theta + r * 5.0) / 6.28318); return abs(spiral - 0.5) - tile * 0.5; }float getPatternSDF(vec2 st, float tile) { st.y -= uTime * 0.05; switch(0) { case 0: return gridSDF(st, tile); case 1: return stripeSDF(st, tile); case 2: return circleSDF(st, tile); case 3: return concentricCircleSDF(st, tile); case 4: return arrowsSDF(st, tile); case 5: return checkerboardSDF(st, tile); case 6: return wavyLinesSDF(st, tile); case 7: return hexagonalSDF(st, tile); case 8: return diamondSDF(st, tile); case 9: return spiralSDF(st, tile); default: return gridSDF(st, tile); } }out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);if(bg.a == 0.) { fragColor = vec4(0); return; } vec4 color = vec4(vec3(0.1607843137254902, 0.1607843137254902, 0.1607843137254902),1.); float aspectRatio = uResolution.x/uResolution.y; float res = max(uResolution.x, uResolution.y); float px = (1./res); float py = px / aspectRatio; float scl = (40. * 1.0000); float minpx = min(px, py); float tile = (minpx + 0.0000/scl)*scl; tile = round(tile / minpx) * minpx;vec2 st = (uv - vec2(0.5, 0.5)) * scl * vec2(aspectRatio, 1); st = st * rotate2d(0.0000 * 360. * 3.1415926 / 180.); float sdf = getPatternSDF(st, tile); float smoothRadius = minpx * scl; float pattern = 1.0 - smoothstep(-smoothRadius, smoothRadius, sdf);color *= pattern;color.rgb = blend(8, color.rgb, bg.rgb); fragColor = mix(bg, color, color.a * 1.0000); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect5"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"coloration","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;vec3 getFilteredColor(vec3 color) { return color; }float hueToRgb(float p, float q, float t) { if (t < 0.0) t += 1.0; if (t > 1.0) t -= 1.0; if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t; if (t < 1.0 / 2.0) return q; if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0; return p; }vec3 hslToRgb(vec3 hsl) { float h = hsl.x; float s = hsl.y; float l = hsl.z; vec3 rgb = vec3(l); if (s != 0.0) { float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s; float p = 2.0 * l - q; rgb.r = hueToRgb(p, q, h + 1.0 / 3.0); rgb.g = hueToRgb(p, q, h); rgb.b = hueToRgb(p, q, h - 1.0 / 3.0); } return rgb; }vec3 rgbToHsl(vec3 rgb) { float max = max(max(rgb.r, rgb.g), rgb.b); float min = min(min(rgb.r, rgb.g), rgb.b); float h, s, l = (max + min) / 2.0;if (max == min) { h = s = 0.0; } else { float d = max - min; s = l > 0.5 ? d / (2.0 - max - min) : d / (max + min); if (max == rgb.r) { h = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6.0 : 0.0); } else if (max == rgb.g) { h = (rgb.b - rgb.r) / d + 2.0; } else if (max == rgb.b) { h = (rgb.r - rgb.g) / d + 4.0; } h /= 6.0; }return vec3(h, s, l); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(color.a <= 0.001) { fragColor = vec4(0); return; }color.rgb = rgbToHsl(color.rgb); color.x = fract(color.x + 1.0000); color.y = clamp(color.y * 1.0000, 0.0, 1.0); color.z = clamp(color.z + -0.0200, 0.0, 1.0); color.rgb = hslToRgb(color.rgb); color.rgb = getFilteredColor(color.rgb);color.rgb = 1.0000 * (color.rgb - 0.5) + 0.5;color.r = clamp(color.r + 0.0000, 0.0, 1.0); color.b = clamp(color.b - 0.0000, 0.0, 1.0);color.g = clamp(color.g - 0.0000, 0.0, 1.0); color.r = clamp(color.r + 0.0000 * 0.5, 0.0, 1.0); color.b = clamp(color.b + 0.0000 * 0.5, 0.0, 1.0);color = vec4(clamp(color.rgb, 0.0, 1.0), color.a); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect6"}],"options":{"name":"assured-hero-bg","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.35","id":"3HtrikvJ5u4C1Z907uCG"}